

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>MATRIX | Microsoft VisualBasic App Framework API docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="baidu-site-verification" content="1ZsVVOmjoT" />
    <meta name="description" content="MATRIXnamespace: Microsoft.VisualBasic.Mathematical.BasicR

 Matlab里常用的矩阵运算函数 %假设矩阵为A det(A)求矩阵行列式 eig(A)求矩阵特征值或特征向量 inv(A)矩阵A求逆 pinv(A)矩阵A求伪逆 rank(A)求矩阵A的秩 svd(A)求矩阵A的奇异值或进行奇异值分解 gsvd(A)求矩阵A的广义奇异值 tr">
<meta property="og:type" content="website">
<meta property="og:title" content="MATRIX">
<meta property="og:url" content="http://framework-docs.xieguigang.me/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html">
<meta property="og:site_name" content="Microsoft VisualBasic App Framework API docs">
<meta property="og:description" content="MATRIXnamespace: Microsoft.VisualBasic.Mathematical.BasicR

 Matlab里常用的矩阵运算函数 %假设矩阵为A det(A)求矩阵行列式 eig(A)求矩阵特征值或特征向量 inv(A)矩阵A求逆 pinv(A)矩阵A求伪逆 rank(A)求矩阵A的秩 svd(A)求矩阵A的奇异值或进行奇异值分解 gsvd(A)求矩阵A的广义奇异值 tr">
<meta property="og:updated_time" content="2016-07-27T12:07:53.037Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MATRIX">
<meta name="twitter:description" content="MATRIXnamespace: Microsoft.VisualBasic.Mathematical.BasicR

 Matlab里常用的矩阵运算函数 %假设矩阵为A det(A)求矩阵行列式 eig(A)求矩阵特征值或特征向量 inv(A)矩阵A求逆 pinv(A)矩阵A求伪逆 rank(A)求矩阵A的秩 svd(A)求矩阵A的奇异值或进行奇异值分解 gsvd(A)求矩阵A的广义奇异值 tr">
    
      <link rel="alternative" href="/atom.xml" title="Microsoft VisualBasic App Framework API docs" type="application/atom+xml">
    
    
      <link rel="icon" href="https://raw.githubusercontent.com/xieguigang/VisualBasic_AppFramework/master/logo.jpg">
    
    <link rel="stylesheet" href="/css/style.css">

    
<!-- Baidu Analytics -->
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fe2c7555911b8560db5e56121c5d5960";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Analytics -->


    <script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>
</head>
<body>
<div id="container"> 

    
    <div id="wrap">
	   

<header id="header" class="hdpage">
    
    <div id="header-outer" class="outer">
        
        <div id="header-inner" class="inner">
          <nav id="main-nav">
            <a id="main-nav-toggle" class="nav-icon"></a>
            
              <a class="main-nav-link" href="/">
                  
                  

                
                  Home
                </a>
            
              <a class="main-nav-link" href="/API">
                  
                  

                
                  API
                </a>
            
              <a class="main-nav-link" href="https://github.com/xieguigang/VisualBasic_AppFramework">
                  
                  

                
                  Github
                </a>
            
          </nav>
          <nav id="sub-nav">
            
              <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
            
            <a id="nav-search-btn" class="nav-icon" title="Search"></a>
          </nav>
          <div id="search-form-wrap">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://framework-docs.xieguigang.me"></form>
          </div>
        </div>
    </div>
</header>
		<div class="outer">
		
    <article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
      <div class="article-meta">
        
          <header class="article-header">
            
  
    <a href="/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html">
      <h1 class="article-title" itemprop="name">
        MATRIX
      </h1>
    </a>
  



          </header>
        

        <!--<a href="/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html" class="article-date">
  <time datetime="2016-07-27T12:07:53.037Z" itemprop="datePublished">2016-07-27</time>
</a>-->
        <!--  -->
      </div>
      <div class="article-inner">
            
            
              <!--<header class="article-header">
                
  
    <a href="/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html">
      <h1 class="article-title" itemprop="name">
        MATRIX
      </h1>
    </a>
  



              </header>-->
            
            <div class="article-entry" itemprop="articleBody">
              <div class="page-toc">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MATRIX"><span class="toc-number">1.</span> <span class="toc-text">MATRIX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Methods"><span class="toc-number">1.0.1.</span> <span class="toc-text">Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Adj"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">Adj</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cond"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">Cond</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cramer22"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">Cramer22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Det2"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">Det2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DetF"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">DetF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFT"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">DFT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EigenValue"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">EigenValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EigSym"><span class="toc-number">1.0.1.8.</span> <span class="toc-text">EigSym</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EigTorF"><span class="toc-number">1.0.1.9.</span> <span class="toc-text">EigTorF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetRank"><span class="toc-number">1.0.1.10.</span> <span class="toc-text">GetRank</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hamiltonian"><span class="toc-number">1.0.1.11.</span> <span class="toc-text">Hamiltonian</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hessenberg"><span class="toc-number">1.0.1.12.</span> <span class="toc-text">Hessenberg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IDFT"><span class="toc-number">1.0.1.13.</span> <span class="toc-text">IDFT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inv"><span class="toc-number">1.0.1.14.</span> <span class="toc-text">Inv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inv2"><span class="toc-number">1.0.1.15.</span> <span class="toc-text">Inv2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lehmer"><span class="toc-number">1.0.1.16.</span> <span class="toc-text">Lehmer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LLt"><span class="toc-number">1.0.1.17.</span> <span class="toc-text">LLt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LU"><span class="toc-number">1.0.1.18.</span> <span class="toc-text">LU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Magic"><span class="toc-number">1.0.1.19.</span> <span class="toc-text">Magic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mul"><span class="toc-number">1.0.1.20.</span> <span class="toc-text">Mul</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number"><span class="toc-number">1.0.1.21.</span> <span class="toc-text">Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#op-Addition"><span class="toc-number">1.0.1.22.</span> <span class="toc-text">op_Addition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#op-BitwiseOr"><span class="toc-number">1.0.1.23.</span> <span class="toc-text">op_BitwiseOr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#op-Division"><span class="toc-number">1.0.1.24.</span> <span class="toc-text">op_Division</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#op-Multiply"><span class="toc-number">1.0.1.25.</span> <span class="toc-text">op_Multiply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#op-Subtraction"><span class="toc-number">1.0.1.26.</span> <span class="toc-text">op_Subtraction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Orth"><span class="toc-number">1.0.1.27.</span> <span class="toc-text">Orth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pascal"><span class="toc-number">1.0.1.28.</span> <span class="toc-text">Pascal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pinv"><span class="toc-number">1.0.1.29.</span> <span class="toc-text">Pinv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pinv2"><span class="toc-number">1.0.1.30.</span> <span class="toc-text">Pinv2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyDiv"><span class="toc-number">1.0.1.31.</span> <span class="toc-text">PolyDiv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyDivEx"><span class="toc-number">1.0.1.32.</span> <span class="toc-text">PolyDivEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyGCF"><span class="toc-number">1.0.1.33.</span> <span class="toc-text">PolyGCF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyGCFCall"><span class="toc-number">1.0.1.34.</span> <span class="toc-text">PolyGCFCall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyMod"><span class="toc-number">1.0.1.35.</span> <span class="toc-text">PolyMod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyMul"><span class="toc-number">1.0.1.36.</span> <span class="toc-text">PolyMul</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PolyRoots2"><span class="toc-number">1.0.1.37.</span> <span class="toc-text">PolyRoots2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pow"><span class="toc-number">1.0.1.38.</span> <span class="toc-text">Pow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QR"><span class="toc-number">1.0.1.39.</span> <span class="toc-text">QR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QR2"><span class="toc-number">1.0.1.40.</span> <span class="toc-text">QR2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QR22"><span class="toc-number">1.0.1.41.</span> <span class="toc-text">QR22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resize"><span class="toc-number">1.0.1.42.</span> <span class="toc-text">Resize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RU"><span class="toc-number">1.0.1.43.</span> <span class="toc-text">RU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scatter"><span class="toc-number">1.0.1.44.</span> <span class="toc-text">Scatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Schmidt"><span class="toc-number">1.0.1.45.</span> <span class="toc-text">Schmidt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SG"><span class="toc-number">1.0.1.46.</span> <span class="toc-text">SG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sove2"><span class="toc-number">1.0.1.47.</span> <span class="toc-text">Sove2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPD"><span class="toc-number">1.0.1.48.</span> <span class="toc-text">SPD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sqrt"><span class="toc-number">1.0.1.49.</span> <span class="toc-text">Sqrt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Svd"><span class="toc-number">1.0.1.50.</span> <span class="toc-text">Svd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SvdSplit"><span class="toc-number">1.0.1.51.</span> <span class="toc-text">SvdSplit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SymTridMatrix"><span class="toc-number">1.0.1.52.</span> <span class="toc-text">SymTridMatrix</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transpose"><span class="toc-number">1.0.1.53.</span> <span class="toc-text">Transpose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VR"><span class="toc-number">1.0.1.54.</span> <span class="toc-text">VR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">1.0.2.</span> <span class="toc-text">Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetSize"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">GetSize</span></a></li></ol></li></ol></li></ol></li></ol>
              </div>
              
                <h1 id="MATRIX"><a href="#MATRIX" class="headerlink" title="MATRIX"></a>MATRIX</h1><p><em>namespace: <a href="N-Microsoft.VisualBasic.Mathematical.BasicR.html">Microsoft.VisualBasic.Mathematical.BasicR</a></em></p>
<blockquote>
<p> Matlab里常用的矩阵运算函数<br> %假设矩阵为A<br> det(A)求矩阵行列式<br> eig(A)求矩阵特征值或特征向量<br> inv(A)矩阵A求逆<br> pinv(A)矩阵A求伪逆<br> rank(A)求矩阵A的秩<br> svd(A)求矩阵A的奇异值或进行奇异值分解<br> gsvd(A)求矩阵A的广义奇异值<br> trace(A)求矩阵A的迹<br> schur(A)对矩阵A进行Schur分解<br> hess(A)求矩阵A的Hessenburg标准型<br> cond(A)求矩阵A的范数<br> chol(A)对矩阵A进行Cholesky分解<br> lu(A)对矩阵A进行lu分解<br> qr(A)对矩阵A进行QR分解<br> poly(A)求矩阵A的特征多项式</p>
</blockquote>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><h4 id="Adj"><a href="#Adj" class="headerlink" title="Adj"></a>Adj</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Adj(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵伴随矩阵</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>目标方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵K的阶数</td>
</tr>
<tr>
<td>Ret</td>
<td>获得的伴随矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 函数采用求代数余子式的方式进行求解,这样就存在一个问题,当目标矩阵的阶数很大的时候,本函数效率是相当慢的。<br> 建议使用左连翠提出的《伴随矩阵的新求法》里的方法进行求解。里面的方法可以求解非满秩矩阵的伴随矩阵。</p>
</blockquote>
<h4 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Cond(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>矩阵范数Cond及</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>目标矩阵</td>
</tr>
<tr>
<td>m</td>
<td>矩阵的行数</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 函数运行原理是先求矩阵的奇异值,然后用最大的奇异值除以最小的奇异值即得矩阵的范数.对于只有1行或者1列的还得另行处理.这个函数和Matlab的Cond命令一样,即2范数</p>
</blockquote>
<h4 id="Cramer22"><a href="#Cramer22" class="headerlink" title="Cramer22"></a>Cramer22</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Cramer22(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>求Kx=B的最小二乘解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>是x的系数矩阵</td>
</tr>
<tr>
<td>B</td>
<td>是等式右边的常数矩阵</td>
</tr>
<tr>
<td>k_m</td>
<td>矩阵K的行数</td>
</tr>
<tr>
<td>x</td>
<td>求解得到的解</td>
</tr>
</tbody>
</table>
<h4 id="Det2"><a href="#Det2" class="headerlink" title="Det2"></a>Det2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Det2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>求行列式</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>所求的n阶方阵</td>
</tr>
<tr>
<td>N</td>
<td>方阵K的阶数</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数成功返回其行列式的大小</em></p>
<h4 id="DetF"><a href="#DetF" class="headerlink" title="DetF"></a>DetF</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.DetF(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>求行列式，函数执行成功返回其行列式大小.其原理是按行列式定义依次展开求解.不适合大于5阶的方阵，K的数组大小为N*N的,不然程序出错</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>为n阶方阵</td>
</tr>
<tr>
<td>N</td>
<td>为矩阵A的阶数</td>
</tr>
</tbody>
</table>
<h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.DFT(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>离散傅里叶变换</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>m*2的矩阵数据(数据点)K里的第一列代表数据的实数部分,第2列代表数据的虚数部分</td>
</tr>
<tr>
<td>m</td>
<td>矩阵k的行数</td>
</tr>
<tr>
<td>Number</td>
<td>离散点数</td>
</tr>
<tr>
<td>X</td>
<td>离散傅里叶变换的结果矩阵是Number*2的矩阵,X里的第一列代表数据的实数部分,第2列代表数据的虚数部分</td>
</tr>
</tbody>
</table>
<p><em>returns: 本函数执行成功返回True.本函数相当于Matlab的快速傅里叶变换函数FFT</em></p>
<h4 id="EigenValue"><a href="#EigenValue" class="headerlink" title="EigenValue"></a>EigenValue</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.EigenValue(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Int16,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Boolean)</span><br></pre></td></tr></table></figure>
<p>方阵求特征值</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K11</td>
<td>要求特征值的方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵K1的阶数</td>
</tr>
<tr>
<td>LoopNumber</td>
<td>循环次数</td>
</tr>
<tr>
<td>Errro</td>
<td>误差控制变量</td>
</tr>
<tr>
<td>Ret</td>
<td>返回的特征值,Ret是是n*2的数组,第一列是实数部分,第2列为虚数部分</td>
</tr>
<tr>
<td>IsHess</td>
<td>K1是否已经是上Hessenberg矩阵</td>
</tr>
</tbody>
</table>
<h4 id="EigSym"><a href="#EigSym" class="headerlink" title="EigSym"></a>EigSym</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.EigSym(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>求对称方阵特征值</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>对称方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵A的阶数</td>
</tr>
<tr>
<td>Erro1</td>
<td>误差控制变量</td>
</tr>
<tr>
<td>Ret</td>
<td>返回的特征值</td>
</tr>
<tr>
<td>Ret_Eigenvectors</td>
<td>返回的特征值对应的特征向量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>本代码采用雅可比过关法求解</p>
</blockquote>
<h4 id="EigTorF"><a href="#EigTorF" class="headerlink" title="EigTorF"></a>EigTorF</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.EigTorF(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Double,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵特征值获取特征值向量</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>目标方阵</td>
</tr>
<tr>
<td>A_m</td>
<td>矩阵A的行数</td>
</tr>
<tr>
<td>EigValve</td>
<td>方阵A的一个特征值</td>
</tr>
<tr>
<td>X</td>
<td>函数执行成功后得到的一个特征向量</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 函数原理:已知方阵A的一个特征值为r,则求解方程组(A-r<em>E)</em>X=0的解X即为我们的一个特征向量(这里E为单位矩阵),<br> 我们下面采用的是全选主元素法求解.但是需要注意的是,由于这个方程组是非满秩矩阵,因此在最后处理解的时候,我们<br> 总是令X解中的一个量为1(当然,你可以设置为其它数,建议设置为非0的数据),然后根据这个量导出其它的量</p>
<p> 例子:<br> a =<br>  [ -1.0000000000000   0.00000000000000   0.00000000000000<br>    8.00000000000000   2.00000000000000   4.00000000000000<br>    8.00000000000000   3.00000000000000   3.00000000000000 ]</p>
<p>  Math_Matrix_EigTor(a,3,6,x)’上面矩阵a的一个特征值为6,则我们执行如下的命令后求得6的特征向量x如下<br> x =<br>  [ 0.00000000000000<br>    1.00000000000000<br>    1.00000000000000 ]</p>
</blockquote>
<h4 id="GetRank"><a href="#GetRank" class="headerlink" title="GetRank"></a>GetRank</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.GetRank(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16)</span><br></pre></td></tr></table></figure>
<p>矩阵求秩，函数执行成功返回秩的大小</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>要求秩的矩阵</td>
</tr>
<tr>
<td>error_</td>
<td>误差控制参数</td>
</tr>
</tbody>
</table>
<h4 id="Hamiltonian"><a href="#Hamiltonian" class="headerlink" title="Hamiltonian"></a>Hamiltonian</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Hamiltonian(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>构建哈密顿矩阵</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>m阶的对称矩阵</td>
</tr>
<tr>
<td>m</td>
<td>矩阵k的行数</td>
</tr>
<tr>
<td>ret</td>
<td>获得的关于矩阵K的Hamiltonian矩阵</td>
</tr>
</tbody>
</table>
<h4 id="Hessenberg"><a href="#Hessenberg" class="headerlink" title="Hessenberg"></a>Hessenberg</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Hessenberg(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>将方阵化为上(Hessenberg)矩阵，函数成功返回Ret的阶数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>要化为上(Hessenberg)矩阵的矩阵</td>
</tr>
<tr>
<td>n</td>
<td>为方阵A的阶数</td>
</tr>
<tr>
<td>ret</td>
<td>化为上(Hessenberg)矩阵后的矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数成功返回Ret的阶数</em></p>
<h4 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.IDFT(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>离散傅里叶变换逆变换</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>m*2的矩阵数据(数据点)K里的第一列代表数据的实数部分,第2列代表数据的虚数部分</td>
</tr>
<tr>
<td>m</td>
<td>矩阵k的行数</td>
</tr>
<tr>
<td>Number</td>
<td>离散点数</td>
</tr>
<tr>
<td>X</td>
<td>离散傅里叶变换逆变换的结果矩阵是Number*2的矩阵,X里的第一列代表数据的实数部分,第2列代表数据的虚数部分</td>
</tr>
</tbody>
</table>
<p><em>returns: 本函数执行成功返回True.本函数相当于Matlab的快速傅里叶变换逆变换函数IFFT</em></p>
<h4 id="Inv"><a href="#Inv" class="headerlink" title="Inv"></a>Inv</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Inv(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵求逆</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>为要求逆的方阵</td>
</tr>
<tr>
<td>Return_K</td>
<td>为所求得的逆</td>
</tr>
</tbody>
</table>
<h4 id="Inv2"><a href="#Inv2" class="headerlink" title="Inv2"></a>Inv2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Inv2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>矩阵求逆</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>目标方阵</td>
</tr>
<tr>
<td>Return_K</td>
<td>求得的逆矩阵</td>
</tr>
<tr>
<td>N</td>
<td>方阵K的阶数</td>
</tr>
</tbody>
</table>
<h4 id="Lehmer"><a href="#Lehmer" class="headerlink" title="Lehmer"></a>Lehmer</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Lehmer(System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>构建Lehmer矩阵</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>构建Lehmer矩阵的阶数</td>
</tr>
<tr>
<td>k</td>
<td>构建的Lehmer矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Lehmer Matrix</p>
</blockquote>
<h4 id="LLt"><a href="#LLt" class="headerlink" title="LLt"></a>LLt</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.LLt(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Boolean)</span><br></pre></td></tr></table></figure>
<p>矩阵的LLt分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>要进行LLt分解的方阵</td>
</tr>
<tr>
<td>L</td>
<td>分解得到的L方阵</td>
</tr>
<tr>
<td>is1_是否已经正定</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数成功返回True,失败返回False.(其中Lt是L的转置,即分解后 A=L×Lt)</em></p>
<h4 id="LU"><a href="#LU" class="headerlink" title="LU"></a>LU</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.LU(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>方阵LU分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>为要LU分解的方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵K的阶数</td>
</tr>
<tr>
<td>L</td>
<td>为分解得到的L矩阵</td>
</tr>
<tr>
<td>U</td>
<td>为分解得到的U矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 其意义是K=LU.函数执行成功返回True,失败返回False</em></p>
<h4 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Magic(System.Int32,System.Double,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>幻方</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>幻方的阶数(大于2)</td>
</tr>
<tr>
<td>start</td>
<td>幻方的中最小的正整数,一般可以设置为1</td>
</tr>
<tr>
<td>k</td>
<td>获得的幻方</td>
</tr>
</tbody>
</table>
<h4 id="Mul"><a href="#Mul" class="headerlink" title="Mul"></a>Mul</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Mul(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵相乘</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K1</td>
<td>K1为矩阵乘法中左边的矩阵</td>
</tr>
<tr>
<td>K2</td>
<td>为矩阵乘法中右边的矩阵</td>
</tr>
<tr>
<td>n</td>
<td>代表K1的列数,K2的行数</td>
</tr>
<tr>
<td>Return_K</td>
<td>执行成功后返回的乘的结果的矩阵</td>
</tr>
</tbody>
</table>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Number</span><br></pre></td></tr></table></figure>
<p>获取仅包含有一个元素的矩阵对象</p>
<h4 id="op-Addition"><a href="#op-Addition" class="headerlink" title="op_Addition"></a>op_Addition</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.op_Addition(System.Double,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>实数加矩阵算符重载，各分量分别加实数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>a1</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="op-BitwiseOr"><a href="#op-BitwiseOr" class="headerlink" title="op_BitwiseOr"></a>op_BitwiseOr</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.op_BitwiseOr(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.VEC)</span><br></pre></td></tr></table></figure>
<p>矩阵乘以向量(线性变换），即 b=Ax</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>-</td>
</tr>
<tr>
<td>x</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="op-Division"><a href="#op-Division" class="headerlink" title="op_Division"></a>op_Division</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.op_Division(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Double)</span><br></pre></td></tr></table></figure>
<p>矩阵除以实数算符重载，各分量分别除以实数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>-</td>
</tr>
<tr>
<td>x</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="op-Multiply"><a href="#op-Multiply" class="headerlink" title="op_Multiply"></a>op_Multiply</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.op_Multiply(System.Double,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>实数乘矩阵算符重载，各分量分别乘以实数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>a1</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="op-Subtraction"><a href="#op-Subtraction" class="headerlink" title="op_Subtraction"></a>op_Subtraction</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.op_Subtraction(System.Double,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>实数减矩阵算符重载，各分量分别减实数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>a1</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="Orth"><a href="#Orth" class="headerlink" title="Orth"></a>Orth</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Orth(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>求矩阵的一个正交基Orth</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>k</td>
<td>目标矩阵</td>
</tr>
<tr>
<td>m</td>
<td>k的行数</td>
</tr>
<tr>
<td>ret</td>
<td>获得的一个正交基矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数失败返回小于1的数据，成功返回ret的行数</em></p>
<blockquote>
<p>对矩阵进行svd分解即用SvdSplit得到k=usv<em>,则s是奇异值矩阵,可以奇异值是否为0获得矩阵的秩r,然后ret就是m</em>r的矩阵且其就是u里的m*r的部分值</p>
</blockquote>
<h4 id="Pascal"><a href="#Pascal" class="headerlink" title="Pascal"></a>Pascal</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Pascal(System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>n阶帕斯卡(Pascal)矩阵</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>表示产生帕斯卡(Pascal)矩阵的阶数</td>
</tr>
<tr>
<td>k</td>
<td>产生的n阶帕斯卡(Pascal)矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Pascal Matrix即产生n阶的帕斯卡矩阵由杨辉三角形表组成的矩阵称为帕斯卡(Pascal)矩阵</p>
</blockquote>
<h4 id="Pinv"><a href="#Pinv" class="headerlink" title="Pinv"></a>Pinv</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Pinv(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵的广义逆A+ ，返回m*n矩阵Return_K(,)的m。此广义逆是Moore-Penrose A+逆</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>要求广义逆的矩阵</td>
</tr>
<tr>
<td>Return_K</td>
<td>求得的广义逆矩阵</td>
</tr>
</tbody>
</table>
<p>_returns: 函数执行成功返回m,其中m代表Return<em>K的行数</em></p>
<h4 id="Pinv2"><a href="#Pinv2" class="headerlink" title="Pinv2"></a>Pinv2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Pinv2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵的广义逆A-，函数执行成功返回Ret的行数,出错返回0</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>要求广义逆的矩阵</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制参数</td>
</tr>
<tr>
<td>m</td>
<td>矩阵K的行数</td>
</tr>
<tr>
<td>Ret</td>
<td>求得的广义逆矩阵</td>
</tr>
</tbody>
</table>
<h4 id="PolyDiv"><a href="#PolyDiv" class="headerlink" title="PolyDiv"></a>PolyDiv</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyDiv(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>多项式除法</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>被除数存储多项式系数</td>
</tr>
<tr>
<td>A2</td>
<td>除数存储多项式系数</td>
</tr>
<tr>
<td>RetMod</td>
<td>求得的余数多项式系数</td>
</tr>
<tr>
<td>Ret</td>
<td>求得的多项式商系数</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制参数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>A1/A2=Ret……RetMod</p>
</blockquote>
<h4 id="PolyDivEx"><a href="#PolyDivEx" class="headerlink" title="PolyDivEx"></a>PolyDivEx</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyDivEx(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>多项式除法</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>被除数存储多项式系数</td>
</tr>
<tr>
<td>A2</td>
<td>除数存储多项式系数</td>
</tr>
<tr>
<td>RetMod</td>
<td>求得的余数多项式系数</td>
</tr>
<tr>
<td>Ret</td>
<td>求得的多项式商系数</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制参数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>A1/A2=Ret……RetMod</p>
</blockquote>
<h4 id="PolyGCF"><a href="#PolyGCF" class="headerlink" title="PolyGCF"></a>PolyGCF</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyGCF(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>多项式提取最大公因式</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>1*A1_n的存储多项式系数的矩阵</td>
</tr>
<tr>
<td>A1_n</td>
<td>A1的列数</td>
</tr>
<tr>
<td>A2</td>
<td>为1*A2_n的存储多项式系数的矩阵</td>
</tr>
<tr>
<td>A2_n</td>
<td>A2的列数</td>
</tr>
<tr>
<td>Ret</td>
<td>获得的最大公因式多项式系数</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制参数</td>
</tr>
</tbody>
</table>
<h4 id="PolyGCFCall"><a href="#PolyGCFCall" class="headerlink" title="PolyGCFCall"></a>PolyGCFCall</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyGCFCall(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>求2个多项式的最大公因式Ret，A1为1<em>A1_n的矩阵，A2为1</em>A2_n的矩阵。函数执行后返回公因式Ret的大小</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>-</td>
</tr>
<tr>
<td>A1_n</td>
<td>-</td>
</tr>
<tr>
<td>A2</td>
<td>-</td>
</tr>
<tr>
<td>A2_n</td>
<td>-</td>
</tr>
<tr>
<td>Ret</td>
<td>-</td>
</tr>
<tr>
<td>Erro</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="PolyMod"><a href="#PolyMod" class="headerlink" title="PolyMod"></a>PolyMod</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyMod(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32)</span><br></pre></td></tr></table></figure>
<p>多项式求余数</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>被除数多项式系数</td>
</tr>
<tr>
<td>A2</td>
<td>除数多项式系数</td>
</tr>
<tr>
<td>Ret</td>
<td>求得的余数多项式系数</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制参数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>A1%A2=Ret</p>
</blockquote>
<h4 id="PolyMul"><a href="#PolyMul" class="headerlink" title="PolyMul"></a>PolyMul</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyMul(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>多项式乘法</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mul1</td>
<td>乘数多项式系数</td>
</tr>
<tr>
<td>Mul2</td>
<td>乘数多项式系数</td>
</tr>
<tr>
<td>Ret</td>
<td>获得的乘积结果多项式系数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Ret=Mul1*Mul2</p>
</blockquote>
<h4 id="PolyRoots2"><a href="#PolyRoots2" class="headerlink" title="PolyRoots2"></a>PolyRoots2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.PolyRoots2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Int16,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>求多项式复数根贝尔斯托(Bairstow)算法</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>多项式系数矩阵,为1*A_n的矩阵。A中的数据依次为多项式最高项系数,次高项系数……常数项系数</td>
</tr>
<tr>
<td>A_n</td>
<td>A矩阵的列数或大小</td>
</tr>
<tr>
<td>LoopNumber</td>
<td>控制的循环次数</td>
</tr>
<tr>
<td>Erro</td>
<td>误差控制变量</td>
</tr>
<tr>
<td>Ret</td>
<td>返回的一个n*2的矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数执行完毕返回Ret的行数</em></p>
<blockquote>
<p> 对于多项式f(x)=(x^2+2x+3)(x^2-5x+9)=x^4-3x^3+2x^2+3x+27,则A(0,0)=1,A(0,1)=-3,A(0,2)=2,A(0,3)=3,A(0,4)=27,A_n=5.<br> 当执行下面的函数后,Ret是一个2×2的矩阵,即Ret(0,0)=2,Ret(0,1)=3,Ret(0,0)的2对应于(x^2+2x+3)当中2x的2,Ret(0,1)的3<br> 对应于(x^2+2x+3)当中常系数的3.用此函数前建议先把重根与实数根处理掉</p>
</blockquote>
<h4 id="Pow"><a href="#Pow" class="headerlink" title="Pow"></a>Pow</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Pow(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>方阵求n次方</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>目标方阵</td>
</tr>
<tr>
<td>m</td>
<td>方阵A的阶数</td>
</tr>
<tr>
<td>n</td>
<td>方阵A要求的次方数</td>
</tr>
<tr>
<td>Ret</td>
<td>方阵A进行n次方后获得的返回值</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 注意,本代码没有采用特征值法。而是直接采用2个矩阵相乘的方法(但又不是老老实实地去乘n次),因为用程序去求一个方阵的特征值,<br> 可能运算复杂度超过了你直接对矩阵相乘的复杂度,至少在n在1000以内大概是这样。</p>
</blockquote>
<h4 id="QR"><a href="#QR" class="headerlink" title="QR"></a>QR</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.QR(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>方阵的QR分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>要QR分解的矩阵，K必须是非奇异的n阶方阵</td>
</tr>
<tr>
<td>Q</td>
<td>分解后的Q矩阵</td>
</tr>
<tr>
<td>R</td>
<td>分解后的R矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数执行成功返回True,失败返回False</em></p>
<h4 id="QR2"><a href="#QR2" class="headerlink" title="QR2"></a>QR2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.QR2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Int16)</span><br></pre></td></tr></table></figure>
<p>矩阵的QR分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>要QR分解的矩阵(不一定是方阵)</td>
</tr>
<tr>
<td>Q</td>
<td>分解得到的Q矩阵</td>
</tr>
<tr>
<td>R</td>
<td>分解得到的R矩阵</td>
</tr>
<tr>
<td>Q_n</td>
<td>返回Q矩阵的列数</td>
</tr>
<tr>
<td>R_n</td>
<td>返回R矩阵的列数</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数成功返回True,失败返回False.使用本函数时,A矩阵的行数不能小于列数</em></p>
<h4 id="QR22"><a href="#QR22" class="headerlink" title="QR22"></a>QR22</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.QR22(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Int16)</span><br></pre></td></tr></table></figure>
<p>矩阵的QR分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>要QR分解的矩阵（不一定是方阵）</td>
</tr>
<tr>
<td>Q</td>
<td>分解得到的Q矩阵</td>
</tr>
<tr>
<td>R</td>
<td>分解得到的R矩阵</td>
</tr>
<tr>
<td>Q_n</td>
<td>返回Q矩阵的列数</td>
</tr>
<tr>
<td>R_n</td>
<td>返回R矩阵的列数</td>
</tr>
</tbody>
</table>
<h4 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Resize(System.Int32,System.Int32)</span><br></pre></td></tr></table></figure>
<p>调整矩阵的大小，并保留原有的数据</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>-</td>
</tr>
<tr>
<td>n</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="RU"><a href="#RU" class="headerlink" title="RU"></a>RU</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.RU(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>右极分解，即F=R*U</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>目标方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵F的阶数</td>
</tr>
<tr>
<td>R</td>
<td>分解得到的一个正交矩阵</td>
</tr>
<tr>
<td>U</td>
<td>分解得到的一个对称正定矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 原理:任何一个可逆方阵均可以唯一的进行右极分解与左极分解,即F=R<em>U=V</em>R,其中U^2=T(F)<em>F,V^2=F</em>T(F)<br>【其中T(F)表示F的转置】,则我们可以先通过F求得U或V,然后求R=F<em>Inv(U)=Inv(V)</em>F</p>
<p> 例子:<br> a =<br>  [ 67.5919611787386     69.8554906388072     38.8768396987006     89.3106376236820<br>    17.0671848194055     1.12767200969517     31.5601159499772     96.9140055109346<br>    40.6681714768839     51.0876563615574     86.9885893943666     77.3506165842296<br>    73.6101518727886     87.9281915202402     23.9508483670423     3.45968334165387 ]</p>
<p> Math_Matrix_RU(a,4,r,u)’进行右极分解得到如下结果<br> r =<br>  [ -0.01806739003090   0.71913865214108  -0.27739456376250   0.63664949766408<br>     0.45823822484909  -0.57214688695250   0.04612554269224   0.67904624212867<br>    -0.09675742692290   0.20970810955629   0.95672796354849   0.17708590026142<br>     0.88326786307616   0.33437989881145   0.07527225185216  -0.31939364294910  ]<br> u =<br>  [ 67.6841644139219  71.9849022272286  26.4791752992667  38.3171883770002<br>    71.9863924990090  89.6984480926248  36.1676400008128  26.2017432919420<br>    26.4820423188876  36.1668446729677  75.6890493922576  53.9420595009903<br>    38.3140405638833  26.2042694530458  53.9408769958847  135.276124831623  ]</p>
<p> Math_Matrix_VR(a,4,v,r)’进行左极分解得到如下结果<br> v =<br>  [ 95.0902981485406     53.4500420292151     61.1182769307013     57.4613130458042<br>    53.4438098825046     74.4408296746995     45.9449363126334    -13.1234428571640<br>    61.1187415068155     45.9418557217637     103.699821171875     34.8450484220080<br>    57.4619847804705    -13.1244040926920     34.8441839555448     95.1168377384350 ]<br> r =<br>  [ -0.01835015300540     0.71939575068999    -0.27678823268990     0.63628327754090<br>     0.45799761221593    -0.57191020194030     0.04534571824682     0.67953103744654<br>    -0.09684035444340     0.20977163011655     0.95676617484504     0.17707600892713<br>     0.88364856259618     0.33406264059053     0.07478222238892    -0.31912379017620 ]</p>
</blockquote>
<h4 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Scatter(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>构建散点图矩阵(Scatter Matrix)</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>目标矩阵</td>
</tr>
<tr>
<td>m</td>
<td>X矩阵的行数</td>
</tr>
<tr>
<td>S</td>
<td>获得的散点矩阵</td>
</tr>
</tbody>
</table>
<h4 id="Schmidt"><a href="#Schmidt" class="headerlink" title="Schmidt"></a>Schmidt</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Schmidt(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵施密特(Schmidt)正交规范化</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>要施密特(Schmidt)正交规范化的矩阵</td>
</tr>
<tr>
<td>Ret</td>
<td>正交规范化后的矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数执行成功返回True,失败返回False</em></p>
<h4 id="SG"><a href="#SG" class="headerlink" title="SG"></a>SG</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.SG(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵的满秩分解Math_Matrinx_SG，把矩阵K分解成一种行满秩Return_m 是m<em>r与列满秩的矩阵Return_n是r</em>n.返回值为r.r是其秩</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>为要满秩分解的方阵</td>
</tr>
<tr>
<td>Return_M</td>
<td>所求得的m*r矩阵</td>
</tr>
<tr>
<td>Return_N</td>
<td>所求得的r*n矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 其中A为m<em>n的矩阵,r为A的秩.即A=Return_M</em>Return_N.函数执行成功返回r(也就是其秩)</p>
</blockquote>
<h4 id="Sove2"><a href="#Sove2" class="headerlink" title="Sove2"></a>Sove2</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Sove2(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>高斯全选主元素法解方程，本函数是求解AX=B这类问题的。函数采用全选主元素的高斯消元法，对于出现非满秩矩阵时(A的化简过程中的A)，<br> 只要函数有解(可能不止一组解,此时只返回一组解)，本函数都能返回其解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>A_m*n的矩阵</td>
</tr>
<tr>
<td>b</td>
<td>B_m*1的矩阵</td>
</tr>
<tr>
<td>A_m</td>
<td>-</td>
</tr>
<tr>
<td>B_m</td>
<td>-</td>
</tr>
<tr>
<td>X</td>
<td>求解得到的矩阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 例子:<br> a =<br>  [ 89.7234413259306  12.9170338217714  79.9443395249286  78.1627263772128<br>    62.8960442556516  63.9951517172135  2.9257326400493   57.119458800703<br>    83.5902038885235  55.9411662425572  89.4671598865963  33.7297967792162 ]</p>
<p> b =<br>  [ 65.2027291083721<br>    54.2041894766522<br>    63.722165657078   ]</p>
<p> 经过本函数后得到的解如下<br> x =<br>  [ -0.826689550370445<br>    0.737377350436936<br>    0.646558671079671<br>    1                 ]</p>
<p> 即AX=B</p>
</blockquote>
<h4 id="SPD"><a href="#SPD" class="headerlink" title="SPD"></a>SPD</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.SPD(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵正规、对称、正定性判断</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>为要判断的矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数返回-1矩阵非对称矩阵,返回0矩阵不正定,返回1矩阵正定</em></p>
<h4 id="Sqrt"><a href="#Sqrt" class="headerlink" title="Sqrt"></a>Sqrt</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Sqrt(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵求平方根（sqrtm）</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>目标方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵K的阶数</td>
</tr>
<tr>
<td>ks</td>
<td>求得的平方根.即ks*ks=K</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 如果K可以化成K=Inv(P)<em>diag(R)</em>P,其中Inv(P)表示P的逆矩阵,diag(R)<em>为K的特征值组成的对角矩阵,<br> 那么ks=Inv(P)</em>diag(R^0.5)<em>P,根据对角化原理,P</em>K*Inv(P)=Diag(R),其中Inv(P)是特征值R对应于K<br> 的特征向量,因此我们的算法=求特征值R,如果所有R均为正实数,则求R对应的特征向量Inv(P),然后讲R每<br> 个值取根放入对角矩阵对结果相乘即可</p>
<p> 例子:<br> c =<br>  [  192.291902022941   136.423323830855  -22.2582056347830   10.9878603820001<br>    -176.869155076020  -120.047935463800   20.4023293672721  -16.5962890811120<br>    -21.6722775306690  -60.5101175154120   135.025037886378   5.36535497517843<br>     31.2279467353500   93.4954928282741  -106.961070363850   59.2865617399033  ]</p>
<p> Math_Matrix_Sqrt(a,4,x)’求a平方根如下,可以进行x*x进行验证<br> x =<br>  [  18.0067271094031   10.1514259204440  -0.80764239842560   0.96148324464486<br>    -13.6679053566890  -5.69822839694800   0.61394536284630  -1.38430646207250<br>    -3.17102914065820  -5.10751280313280   11.6191076697081   0.04254172112235<br>     4.81532683312183   7.92820343443191  -5.38805756370240   8.16305909603188  ]</p>
</blockquote>
<h4 id="Svd"><a href="#Svd" class="headerlink" title="Svd"></a>Svd</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Svd(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>矩阵奇异值</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>为目的矩阵</td>
</tr>
<tr>
<td>m</td>
<td>为A矩阵的行数</td>
</tr>
<tr>
<td>Ret</td>
<td>获取到的奇异值矩阵,即返回的Ret是m*1的矩阵</td>
</tr>
</tbody>
</table>
<p><em>returns: 函数执行成功返回奇异值的个数,即Ret的行数,失败返回-1</em></p>
<h4 id="SvdSplit"><a href="#SvdSplit" class="headerlink" title="SvdSplit"></a>SvdSplit</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.SvdSplit(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16)</span><br></pre></td></tr></table></figure>
<p>对矩阵A进行奇异值分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>目标矩阵</td>
</tr>
<tr>
<td>m</td>
<td>A矩阵的行数</td>
</tr>
<tr>
<td>V</td>
<td>分解得到的一个V矩阵</td>
</tr>
<tr>
<td>V_m</td>
<td>V矩阵的行数</td>
</tr>
<tr>
<td>S</td>
<td>分解得到的一个S矩阵</td>
</tr>
<tr>
<td>S_m</td>
<td>S矩阵的行数</td>
</tr>
<tr>
<td>U</td>
<td>分解得到的一个U矩阵</td>
</tr>
<tr>
<td>U_m</td>
<td>U矩阵的行数</td>
</tr>
</tbody>
</table>
<h4 id="SymTridMatrix"><a href="#SymTridMatrix" class="headerlink" title="SymTridMatrix"></a>SymTridMatrix</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.SymTridMatrix(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int16,System.Boolean,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>实对称阵化为对称三对角阵</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>目标方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵A的阶数</td>
</tr>
<tr>
<td>Is对称</td>
<td>不确定是否对称直接填False,对称则直接填True</td>
</tr>
<tr>
<td>ret</td>
<td>返回的三对角阵</td>
</tr>
</tbody>
</table>
<blockquote>
<p>本函数采用用豪斯赫尔蒙德变换将实对称阵化为对称三对角</p>
</blockquote>
<h4 id="Transpose"><a href="#Transpose" class="headerlink" title="Transpose"></a>Transpose</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.Transpose</span><br></pre></td></tr></table></figure>
<p>获取当前的矩阵对象的转置矩阵</p>
<h4 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.VR(Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,System.Int32,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX,Microsoft.VisualBasic.Mathematical.BasicR.MATRIX)</span><br></pre></td></tr></table></figure>
<p>左极分解</p>
<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>目标方阵</td>
</tr>
<tr>
<td>n</td>
<td>方阵F的阶数</td>
</tr>
<tr>
<td>V</td>
<td>分解得到的一个对称正定矩阵</td>
</tr>
<tr>
<td>R</td>
<td>分解得到的一个正交矩阵，即F=V*R</td>
</tr>
</tbody>
</table>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><h4 id="GetSize"><a href="#GetSize" class="headerlink" title="GetSize"></a>GetSize</h4><p>获取矩阵行数</p>

              
            </div>
            <footer class="article-footer">
              <a href="/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html" class="article-date">
  <time datetime="2016-07-27T12:07:53.037Z" itemprop="datePublished">2016-07-27</time>
</a>
              <a data-url="http://framework-docs.xieguigang.me/API/T-Microsoft.VisualBasic.Mathematical.BasicR.MATRIX.html" data-id="cipfqyhji00jir0v4vb5c7s7y" class="article-share-link">Share</a>
              
              
            </footer>
      </div>
      
        
      
    </article>
    <script type="text/javascript">
      window.onscroll = function(){ 
        $(function(){
          var $toc = $('.page-toc'),
              $article = $('.article-entry')
              toc_top = $toc.offset().top
              tocsub_width = $toc.children().width()
              article_height = $article.children().height()
              scroll_top = document.body.scrollTop
              screen_h = $(window).height()
              footer_top = $('.article-footer').offset().top - $(window).height()
              if(toc_top&&scroll_top&&scroll_top>toc_top&&scroll_top<footer_top){
                $toc.children().css({
                  "position": "fixed",
                  "height": (screen_h -20)+'px',
                  "overflow": "auto"
                })
                $article.css('margin-right',tocsub_width+'px')
              }else{
                $toc.children().css({
                  "position": "relative",
                  "height":'inherit',
                  "overflow": "auto"
                })
                $article.css('margin-right',0+'px')
              }
        })
      } 
    </script>








		</div>
		

<footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
        <div class="left">
            &copy; 2016 谢桂纲<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/jaywcjlove/hexoThemeKacper">hexoThemeKacper </a>
        </div>
        <div class="right">
            
        </div>
    </div>
  </div>
</footer>
<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


<script type="text/javascript">
$(function(){
  var $img = $('.article-entry img'),
      $link = $img.css({
        "display":"inline-block"
      }).parent()

  if($link.parent().is("a")){
      $img.each(function(idx,item) {
      $(this).parent().attr('href',$(this).parent().parent().attr('href'))
    })
  }
})
</script>


<script src="/js/script.js"></script>

  	</div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/API" class="mobile-nav-link">API</a>
  
    <a href="https://github.com/xieguigang/VisualBasic_AppFramework" class="mobile-nav-link">Github</a>
  
</nav>
    
</div>
</body>
</html>

